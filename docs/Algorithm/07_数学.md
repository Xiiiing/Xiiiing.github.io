# 数学

#### 最大公约数 最小公倍数 唯一分解定理

> $\gcd(a, b) = \gcd(b, a\%b)$

```c++
// 1. 最大公约数（GCD）- 欧几里得算法（迭代版）
int gcd(int a,int b)
{
    if(b==0) return a;
    else return gcd(b,a%b);
}

// 2. 最小公倍数（LCM）- 基于GCD计算
long long lcm(long long a, long long b) {
    if (a == 0 || b == 0) return 0; // 0和任何数的最小公倍数是0
    return (a / gcd(a, b)) * b; // 先除后乘避免溢出
}
```

#### 分解质因数 判定素数 素数筛

> 分解质因数

```c++
vector<int> primeFactorization(int n) {
    vector<int> factors;
    for (int i = 2; i * i <= n; i++) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) factors.push_back(n);
    return factors;
}
```

> 素数筛:使用素数的倍数去筛掉合数
>
> 但是一个合数会被多次素数筛除影响效率

```c++
bool isnp[MAXN]; // is not prime: 不是素数
void init(int n)
{
    for (int i = 2; i * i <= n; i++)
        if (!isnp[i])
            for (int j = i * i; j <= n; j += i)
                isnp[j] = 1;
}
```

> 引入欧拉筛:不会重复筛除
>
> 合数只筛一次 保证是被最小质因数筛除
>
> 质数就需要遍历全部筛除

```c++
bool isnp[MAXN];
vector<int> primes; // 质数表
void init(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if (!isnp[i])
            primes.push_back(i);
        for (int p : primes)
        {
            //越界退出 使用乘法快于除法
            if (p * i > n)
                break;
            isnp[p * i] = 1;
            //合数只筛一次 保证是被最小质因数筛除
            if (i % p == 0)
                break;
        }
    }
}
```

#### 快速幂

> 非递归快速幂

```java
    private static int poww(int a,int b){
        int result = 1;
        while(b!=0){
            if(b%2!=0) result *=a; 
            a*= a;
            b>>=1;
            System.out.println(b);
        }
        return result;
    }

```

> 矩阵快速幂
>
> **应用**:①先根据题意求出递推公式
> ②根据递推公式写出它的转移矩阵T，即TX^ (n-1)=X^ n。注意此转移矩阵的系数不包含未知数，这样才可以进行第③步
> ③求出转移矩阵T后，TX^ (n-1)=X^ n，利用矩阵的快速幂求出X^(n-1)的值，最后乘以系数矩阵T（也称为转移矩阵）得出矩阵X ^ n的值

```java
    private static long[][] multiply(long[][] a, long[][] b,int n,int mod){

        long[][] result = new long[80][80];
        for(int i=1;i<=2*n;i++){
            for(int j=1;j<=2*n;j++){
                for(int k=1;k<=2*n;k++){
                    result[i][j] += ((a[i][k]*b[k][j])%mod);
                    result[i][j] %=mod;
                }
            }
        }
        return result;
    }

    private static long[][] quick(int k,int n,int mod){
    
        long[][] cur = new long[80][80];
        long[][] result = new long[80][80];

        for(int i=1;i<=2*n;i++){
            result[i][i]=1;
        }
        cur = matrix;

        while(k!=0){
            if(k%2 ==1) result = multiply(result, cur, n, mod);
            cur = multiply(cur, cur, n, mod);
            k/=2; 
        }
        return result;
    }

```

####  费马小定理逆元

 该公式为 **费马小定理（Fermat's Little Theorem）** 的表达式，具体解析如下： ### 定理内容 若 \( p \) 是 **质数**，且整数 \( a \) 满足 \( p \nmid a \)（即 \( a \) 与 \( p \) 互质），则：   \[ a^{p-1} \equiv 1 \pmod{p} \] ### 数学意义 - **模运算性质**：在模 \( p \) 的乘法群中，元素 \( a \) 的 \( p-1 \) 次幂同余于 1（乘法群阶为 \( p-1 \)，由拉格朗日定理，元素阶整除群阶）。   - **应用场景**：简化模幂计算（如密码学中的 RSA 算法）、数论证明（如判断质数的概率性测试，如费马测试）。 ### 示例 - 取 \( p=5 \)（质数），\( a=2 \)（与 5 互质），则 \( 2^4 = 16 \equiv 1 \pmod{5} \)，验证成立。   - 若 \( p=4 \)（非质数），\( a=3 \)（与 4 互质），则 \( 3^3 = 27 \equiv 3 \pmod{4} \neq 1 \)，说明非质数时定理不成立。 ### 条件强调 - **\( p \) 必须是质数**，否则定理失效（如上述 \( p=4 \) 的反例）。   - **\( a \) 与 \( p \) 互质**（即 \( \gcd(a,p)=1 \)），若 \( p \mid a \)，则 \( a^{p-1} \equiv 0 \pmod{p} \neq 1 \)（除非 \( a \equiv 0 \pmod{p} \) 且 \( p=2, a=0 \) 等 trivial 情况，但通常定理要求 \( a \not\equiv 0 \pmod{p} \)）。 ### 结论 该公式是数论中核心定理之一，描述了质数模下互质整数的幂次同余特性，需在 **\( p \) 为质数且 \( a \) 与 \( p \) 互质** 的条件下使用，广泛应用于密码学、算法设计等领域。 **答案**：该公式为费马小定理，形式为 \(a^{p-1} \equiv 1 \pmod{p}\)（其中 \(p\) 为质数，\(a\) 与 \(p\) 互质）。

> 若 a 与质数 p 互质$a^{p-1} \equiv 1 \pmod{p}$

```c++
long long quickpow(long long a,long long n)
{
    a%=mod;
    long long res=1;
    while(n>0)
    {
        if(n&1) res=(res*a)%mod;
        a=(a*a)%mod;
        n>>=1;
    }
    return res;
}
long long inv(long long a)
{
    return quickpow(a,mod-2);
}
```

#### exgcd

> $\gcd(a, 0) = a$
>
> $ax_1 + by_1 = \gcd(a, b) =bx_2 + (a \bmod b)y_2 = \gcd(b, a \bmod b)$

```java
public class ExtendedGCD {
    /**
     * 计算 a 和 b 的扩展欧几里得算法
     * 返回一个长度为 3 的数组：
     *   res[0] = gcd(a, b)
     *   res[1] = x
     *   res[2] = y
     * 使得 ax + by = gcd(a, b)
     */
    public static long[] exgcd(long a, long b) {
        if (b == 0) {
            // a*1 + b*0 = a
            return new long[]{a, 1, 0};
        }
        // 递归计算 g = gcd(b, a % b)，同时得到系数 x1, y1
        long[] res = exgcd(b, a % b);
        long g = res[0];
        long x1 = res[1];
        long y1 = res[2];
        // 由 b*x1 + (a%b)*y1 = g
        // 且 a%b = a - (a/b)*b
        // => b*x1 + (a - (a/b)*b)*y1 = g
        // => a*y1 + b*(x1 - (a/b)*y1) = g
        long x = y1;
        long y = x1 - (a / b) * y1;
        return new long[]{g, x, y};
    }

    public static void main(String[] args) {
        long a = 35, b = 10;
        long[] res = exgcd(a, b);
        System.out.printf("gcd(%d, %d) = %d\n", a, b, res[0]);
        System.out.printf("x = %d, y = %d => %d*%d + %d*%d = %d\n",
                          res[1], res[2], a, res[1], b, res[2], res[0]);
    }
}

```

#### 欧拉函数 欧拉降幂

#### min25筛 杜教筛

#### 排列组合 斯特林数

#### 卡特兰数

