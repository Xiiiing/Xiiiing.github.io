# 数学

### 最大公约数 最小公倍数 唯一分解定理

> $\gcd(a, b) = \gcd(b, a\%b)$

```c++
// 1. 最大公约数（GCD）- 欧几里得算法（迭代版）
int gcd(int a,int b)
{
    if(b==0) return a;
    else return gcd(b,a%b);
}

// 2. 最小公倍数（LCM）- 基于GCD计算
long long lcm(long long a, long long b) {
    if (a == 0 || b == 0) return 0; // 0和任何数的最小公倍数是0
    return (a / gcd(a, b)) * b; // 先除后乘避免溢出
}
```

### 分解质因数 判定素数 素数筛

> 分解质因数

```c++
vector<int> primeFactorization(int n) {
    vector<int> factors;
    for (int i = 2; i * i <= n; i++) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) factors.push_back(n);
    return factors;
}
```

> 素数筛:使用素数的倍数去筛掉合数
>
> 但是一个合数会被多次素数筛除影响效率

```c++
bool isnp[MAXN]; // is not prime: 不是素数
void init(int n)
{
    for (int i = 2; i * i <= n; i++)
        if (!isnp[i])
            for (int j = i * i; j <= n; j += i)
                isnp[j] = 1;
}
```

> 引入欧拉筛:不会重复筛除
>
> 合数只筛一次 保证是被最小质因数筛除
>
> 质数就需要遍历全部筛除

```c++
bool isnp[MAXN];
vector<int> primes; // 质数表
void init(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if (!isnp[i])
            primes.push_back(i);
        for (int p : primes)
        {
            //越界退出 使用乘法快于除法
            if (p * i > n)
                break;
            isnp[p * i] = 1;
            //合数只筛一次 保证是被最小质因数筛除
            if (i % p == 0)
                break;
        }
    }
}
```

### 快速幂

> 非递归快速幂

```java
    private static int poww(int a,int b){
        int result = 1;
        while(b!=0){
            if(b%2!=0) result *=a; 
            a*= a;
            b>>=1;
            System.out.println(b);
        }
        return result;
    }

```

> 矩阵快速幂
>
> **应用**:①先根据题意求出递推公式
> ②根据递推公式写出它的转移矩阵T，即TX^ (n-1)=X^ n。注意此转移矩阵的系数不包含未知数，这样才可以进行第③步
> ③求出转移矩阵T后，TX^ (n-1)=X^ n，利用矩阵的快速幂求出X^(n-1)的值，最后乘以系数矩阵T（也称为转移矩阵）得出矩阵X ^ n的值

```java
    private static long[][] multiply(long[][] a, long[][] b,int n,int mod){

        long[][] result = new long[80][80];
        for(int i=1;i<=2*n;i++){
            for(int j=1;j<=2*n;j++){
                for(int k=1;k<=2*n;k++){
                    result[i][j] += ((a[i][k]*b[k][j])%mod);
                    result[i][j] %=mod;
                }
            }
        }
        return result;
    }

    private static long[][] quick(int k,int n,int mod){
    
        long[][] cur = new long[80][80];
        long[][] result = new long[80][80];

        for(int i=1;i<=2*n;i++){
            result[i][i]=1;
        }
        cur = matrix;

        while(k!=0){
            if(k%2 ==1) result = multiply(result, cur, n, mod);
            cur = multiply(cur, cur, n, mod);
            k/=2; 
        }
        return result;
    }

```

### exgcd

> $\gcd(a, 0) = a$
>
> $ax_1 + by_1 = \gcd(a, b) =bx_2 + (a \bmod b)y_2 = \gcd(b, a \bmod b)$

```java
public class ExtendedGCD {
    /**
     * 计算 a 和 b 的扩展欧几里得算法
     * 返回一个长度为 3 的数组：
     *   res[0] = gcd(a, b)
     *   res[1] = x
     *   res[2] = y
     * 使得 ax + by = gcd(a, b)
     */
    public static long[] exgcd(long a, long b) {
        if (b == 0) {
            // a*1 + b*0 = a
            return new long[]{a, 1, 0};
        }
        // 递归计算 g = gcd(b, a % b)，同时得到系数 x1, y1
        long[] res = exgcd(b, a % b);
        long g = res[0];
        long x1 = res[1];
        long y1 = res[2];
        // 由 b*x1 + (a%b)*y1 = g
        // 且 a%b = a - (a/b)*b
        // => b*x1 + (a - (a/b)*b)*y1 = g
        // => a*y1 + b*(x1 - (a/b)*y1) = g
        long x = y1;
        long y = x1 - (a / b) * y1;
        return new long[]{g, x, y};
    }

    public static void main(String[] args) {
        long a = 35, b = 10;
        long[] res = exgcd(a, b);
        System.out.printf("gcd(%d, %d) = %d\n", a, b, res[0]);
        System.out.printf("x = %d, y = %d => %d*%d + %d*%d = %d\n",
                          res[1], res[2], a, res[1], b, res[2], res[0]);
    }
}

```

###  逆元

#### 费马小定理

对于整数 $a$ 与正整数模 $m$，若 $\gcd(a,m)=1$，则在同余类环 $\mathbb{Z}/m\mathbb{Z}$ 中存在唯一的 $x$ 使得
$
a\,x \equiv 1 \pmod m.
$
这时称 $x$ 是 $a$ 关于模 $m$ 的逆元，记为
$
x \equiv a^{-1}\pmod m.
$

> 若 a 与质数 p 互质$a^{p-1} \equiv 1 \pmod{p}$
>
> 也就是说，当模数为质数，且需要求逆元的数与模数互质时，可通过快速幂直接求取其逆元。

```c++
long long quickpow(long long a,long long n)
{
    a%=mod;
    long long res=1;
    while(n>0)
    {
        if(n&1) res=(res*a)%mod;
        a=(a*a)%mod;
        n>>=1;
    }
    return res;
}
long long inv(long long a)
{
    return quickpow(a,mod-2);
}
```

#### exgcd求逆元

```c++
long long exgcd(long long a,long long b,long long &x,long long &y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    long long ans=exgcd(b,a%b,x,y);
    long long temp=x;
    x=y;
    y=temp-a/b*y;
    return ans;
}
long long inv(long long a,long long p)
{
    long long x,y;
    long long g=exgcd(a,p,x,y);
    if(g!=1) return -1;//不互质则无解
    else return (x%p+p)%p;
}
```

#### 快速求多个逆元

```c++
int inv[1000000];
void find_inv(int last,int p)//求1~last所有数模p意义下的逆元
{
    inv[1]=1;//1的逆元就是1本身
    for(int i=2;i<=last;i++)
        inv[i]=(long long)(p-p/i)*(inv[p%i])%p;
    //注意longlong，否则有可能导致溢出
}
```

### 欧拉函数 欧拉降幂

数论中的**欧拉函数** $\varphi(x)$ 是一个非常重要的函数，它定义为小于（或不大于，这里是一样的）$x$ 但与 $x$ 互质的正整数的数量。例如
$
\varphi(12)=4,
$
因为 $1,5,7,11$ 与 $12$ 互质。特别地，规定
$
\varphi(1)=1.
$
对于欧拉函数，主要有如下性质：

1. 若 $p$ 是质数，则
   $
   \varphi\bigl(p^n\bigr)=p^{n-1}(p-1).
   $

2. 若 $a\mid x$，则
   $
   \varphi(a x)=a\,\varphi(x).
   $

3. 若 $\gcd(a,b)=1$，则
   $
   \varphi(a)\,\varphi(b)=\varphi(a b).
   $

### min25筛 杜教筛

### 排列组合 斯特林数

### 卡特兰数

