### 序言

#### 空间复杂度

8 b=1 B

1024 B=1 KB

1024 KB=1 MB

1024 MB=1 GB

int :4 B, long : 8 B ,  boolean :1 B

int 是2e31=21亿

long 是9×10e18

#### 时间复杂度

一般情况下，评测机 1 秒钟能执行 2×10e8，（测试蓝桥评测机能跑 5×10e8，测试方式为其能在 900ms 跑完 5×10e8 的除法）但实际情况下，代码通常含有大量其他操作，不仅仅只有一步，因此建议估算 1 秒钟依旧以 2×10e8 为标准。
需要注意，定义数组也需要时间，数组大小越大，耗时越长，一般 2×107 大小的数组，定义出来需要 2 秒以上，因此比赛中建议数组大小不超过 5×10e6。

### 基础算法

#### 前缀和

- [ ] ##### 一维

> **原理:**利用$s [i] = s [i-1] + a [i]$求出任意区间 $[l, r]$ 的和，即 $s [r] - s [l-1]$
>
> **应用:**快速求解数组中任意区间的和，例如在多次查询区间和的问题

- [ ] ##### 二维

> **原理:** 计算公式为$s [i][j] = s [i-1][j] + s [i][j-1] - s [i-1][j-1] + a [i][j]$ 利用二维前缀和求出任意子矩阵的和，即 $s [x2][y2] - s [x1-1][y2] - s [x2][y1-1] + s [x1-1][y1-1]$
>
> **应用:**快速计算二维数组中任意子矩阵的和

#### 差分

- [ ] ##### 一维差分

> **原理:**对于一维数组 $a [1...n]$，构造差分数组 $d [1...n]$，使得 $a [i] = d [1] + d [2] + ... + d [i]$，即 $d [1] = a [1]，d [i] = a [i] - a [i-1]（i≥2）$。当需要对原数组的区间 $[l, r]$ 进行加 c 操作时，只需在差分数组中 $d [l] += c，d [r+1] -= c（若 r+1≤n）$，最后通过差分数组求前缀和即可得到更新后的原数组。
>
> **应用:**高效处理数组的区间更新问题，当有大量区间更新操作时，使用差分可以将每次更新的时间复杂度降为 O (1)

#### 二分

- [ ] ##### 序列二分

> **原理:**在有序序列中，通过不断将区间缩小为原来的一半，来查找目标元素。每次比较中间元素与目标元素的大小，确定下一步搜索的区间。
>
> **应用:**在有序数组中查找元素是否存在、查找元素的第一个位置或最后一个位置等。

```java
int binarySearch(int l, int r, int key) {
    int ret = -1;
    while (l <= r) {
            int mid = l + ((r - l) >> 1);
            if (arr[mid] < key) {
                l = mid + 1;
            } else if (arr[mid] > key) {
                r = mid - 1;
            } else {
                ret = mid;      // 记录位置
                r = mid - 1;  // 继续往左找
                //l =mid+1; 继续往右找
            }
        }
        return ret;
    }
```



- [ ] ##### 答案二分


> **原理:**将求解的问题转化为判断某个值是否满足条件，通过二分答案的可能范围，每次判断当前中间值是否满足条件，从而缩小答案的范围，直到找到满足条件的最小或最大值。
>
> **应用:**求解满足某种条件的最优解问题，如求最小的满足条件的数值、最大的不满足条件的数值等。

```java
static int find(int[] a, int n, int m) {
        int l = 1;
        int r = 1000000001; // 1e9 + 1，Java中直接使用整数常量

        while (l <= r) {
            int mid = (l + r) / 2;
            if (check(mid, a, n, m)) {
                l = mid+1;
            } else {
                r = mid-1;
            }
        }
        return r;//一般情况是r  根据check定义
}
```

- [ ] ##### 浮点数二分


> **原理:**与整数二分类似，但由于浮点数的精度问题，需要设置一个足够小的精度范围（如 1e-8），当区间长度小于该精度时停止二分，取中间值作为结果。
>
> **应用:**求解浮点数的方程根、求浮点数的极值等问题。

```java
double l = 0, r = 1e9;
    while(r - l > eps){
        double mid =  (r + l) / 2;
        if(check(mid))
            l = mid;
        else
            r = mid;
    }
    printf("%.2f",l);
    return 0;
```

#### 双指针

- [ ] ##### 前后指针


> **原理:**使用两个指针，一个从前向后遍历，一个从后向前遍历，根据题目条件调整指针的位置，从而解决问题。
>
> **应用:**常用于数组或字符串的遍历问题，如判断回文字符串（一个指针从开头，一个从结尾，向中间移动比较字符）、数组中的元素配对问题等。

- [ ] ##### 左右指针


> **原理:**两个指针都从数组的一端（通常是左端）开始，向右移动，根据特定条件调整其中一个或两个指针的位置，以找到满足条件的区间或元素。
>
> **应用:**求解滑动窗口问题（如最小覆盖子串）、有序数组中的和为目标值的元素对问题等。

#### 位运算

> **原理:**直接对整数在二进制层面上进行操作，包括与（&）、或（|）、异或（^）、左移（<<）、右移（>>）等操作。利用位运算可以高效地处理二进制位相关的问题。
>
> **应用:**判断整数的奇偶性（通过判断最后一位是否为 1）、求一个数的二进制中 1 的个数、整数的快速乘除（左移相当于乘 2，右移相当于除以 2）、状态压缩（如用一个整数表示多个开关的状态）等。

#### 找规律

> **原理:**
>
> **应用:**

### 搜索

#### 递归回溯

> **原理:**采用递归的方式遍历所有可能的解空间，当发现当前路径不满足条件时，回溯到上一步，尝试其他路径。通过递归函数的参数来记录当前的状态，如已选的元素、当前的位置等。
>
> **应用:**解决排列组合问题（如全排列、子集生成）、迷宫求解问题、数独求解问题等。

#### 二进制枚举

> **原理:**将问题中的状态用二进制数表示，每一位代表一个元素是否被选中或某种状态是否存在，然后枚举所有可能的二进制数（从 0 到 2^n-1，n 为元素个数），对应不同的状态组合，判断是否满足条件。
>
> **应用:**处理状态压缩问题，如集合的子集问题、资源分配问题（每个资源是否被使用）等。

#### DFS

> **原理:**从图的某个顶点出发，沿着一条路径尽可能深地搜索下去，直到无法继续，然后回溯到上一个顶点，搜索其他路径。通常使用递归或栈来实现。
>
> **应用:**图的遍历（如查找图中的所有连通分量）、求解连通性问题、迷宫路径搜索、求解所有可能的解（如排列组合问题的另一种解法）等。

#### BFS

> **原理:**从图的某个顶点出发，先访问其所有相邻顶点，再依次访问这些相邻顶点的相邻顶点，按照层的顺序进行搜索，通常使用队列来实现。
>
> **应用:**图的遍历（如求最短路径问题，在无权图中，BFS 可以找到从起点到终点的最短路径）、寻找连通分量、解迷宫问题（求最短出口路径）等。

### 数据结构

#### 优先队列

> **原理:**基于堆结构实现（大根堆或小根堆），自动对元素进行排序，每次取出堆顶元素（最大或最小元素）。插入和删除操作的时间复杂度均为 O (log n)。
>
> **应用:**处理需要频繁获取最大或最小元素的问题，如 Dijkstra 算法中用于选取当前距离最小的节点、任务调度问题（每次选取优先级最高的任务）等。

#### 哈希表

> **原理:**过哈希函数将键映射到数组中的某个位置，实现快速的查找、插入和删除操作。哈希函数的设计至关重要，要尽量减少冲突，常用的解决冲突的方法有开放寻址法和链地址法。
>
> **应用:**快速查找数据（如判断某个元素是否存在于集合中）、统计元素的出现次数（如在 “字母异位词分组” 问题中，用哈希表记录每个字母排序后的字符串对应的分组）等。

#### 并查集

> **原理:**每个集合用一个根节点表示，每个节点存储其父节点，通过路径压缩和按秩合并优化，使得查找和合并操作的时间复杂度接近 O (1)。
>
> **应用:**解决不相交集的合并

#### 单调栈

> **原理:**栈中的元素保持单调递增或递减的顺序。当新元素入栈时，弹出栈中不满足单调性的元素，直到栈顶元素满足单调性条件，然后将新元素入栈。
>
> **应用:**求解序列中每个数最左边或最右边第一个大于（或小于）其的数
>
> ​	 求解序列中所有子序列的最值和

#### 单调队列

> **原理:**队列中的元素保持单调递增或递减的顺序。当新元素进入队列时，从队列尾部删除比新元素大（或小）的元素，然后将新元素加入队尾；同时，从队列头部删除超出窗口范围的元素。
>
> **应用:**求解序列中每个长度为 k 的窗口的最值（最大值或最小值）。

### 图论

### 动态规划

#### 数位dp

秒杀一切数位dp(记忆化搜索)

#### 记忆化搜索

#### 背包问题

01背包,

#### 线性dp

### 字符串

#### 字符串哈希

#### kmp

#### manacher

#### 字典树

### 数学

#### 最大公约数 最小公倍数 唯一分解定理



#### 分解质因数 判定素数 素数筛

#### 快速幂 费马小定理逆元 

#### exgcd

#### 欧拉函数 欧拉降幂

#### min25筛 杜教筛

#### 排列组合 斯特林数

#### 卡特兰数









> **原理:**
>
> **应用:**







![image-20250517133325870](C:\Users\31908\AppData\Roaming\Typora\typora-user-images\image-20250517133325870.png)

