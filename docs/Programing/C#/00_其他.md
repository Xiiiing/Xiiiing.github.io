# 其他

## 1、自动属性

当定义了如下类时，编译器会自动为它生成一个隐藏的、名称不固定的私有字段（比如可能叫 `<L_A>k__BackingField`这类编译器生成的名字 ）而不是代码里写的 `name`。所以当通过反射给 `Name` 属性赋值时，修改的是编译器生成的那个隐藏字段，和你手动定义的 `name` 无关。

```c#
public class Person
{
    private string name;
    public string Name { get; set; }
}
```

**解决方法**

- 改用手动实现属性（让属性直接操作`name`字段 ）

```c#
public class Person
{
    private string name;
    public string Name
    {
        get { return name; }
        set { name = value; }
    }
}
```

- 反射直接操作 `name` 字段（不通过属性）
  
``` c#
// 假设 obj 是包含这些成员的对象实例object
obj = new YourClass(); 
Type type = obj.GetType();
// 注意字段名是 "l\_A"，区分大小写FieldInfo
 fieldInfo = type.GetField("name", BindingFlags.Instance | BindingFlags.NonPublic);
  if (fieldInfo != null)
  { 
    fieldInfo.SetValue(obj, 123.45); // 直接给私有字段赋值
  }
```

## 2、方法重载

在使用**重载方法**时，当传入子类对象时，方法的选择（即调用哪个重载版本）**取决于编译时的静态类型**，**而不是运行时的实际类型**。这与**重写**（Override）的**动态绑定机制**不同。

**具体来说**

- 重载方法的匹配是在编译阶段根据**参数的声明类型**（静态类型）决定的
- 即使实际传入的是子类对象，只要声明类型是基类，就会匹配接收基类参数的重载版本

#### <font color="red"> 重载方法的选择基于编译时的静态类型

#### 重写方法的选择基于运行时的实际类型</font>

## 3、Type

在C#中，如果你有一个基类对象引用指向一个子类对象，当你调用这个基类对象的`GetType()`方法时，它将返回子类的类型。这是因为`GetType()`方法返回的是实际对象的**运行时类型**，而不是引用的类型。

```csharp
public class BaseClass
{
    // 基类代码
}

public class SubClass : BaseClass
{
    // 子类代码
}

public class Program
{
    public static void Main()
    {
        BaseClass baseObj = new SubClass();
        Type type = baseObj.GetType();
        Console.WriteLine(type); // 输出: SubClass
    }
}
```

运行这段代码，输出将是SubClass